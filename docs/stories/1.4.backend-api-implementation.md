# Story 1.4: Backend API Implementation

## Status

Draft

## Story

**As a** Backend Developer,
**I want** to create API endpoints for package information and capacity management with database seeding and Redis caching,
**so that** the frontend can display accurate, real-time package availability and pricing with proper performance optimization.

## Acceptance Criteria

1. **AC1:** GET /api/packages endpoint returning package types, pricing, features, and current availability

2. **AC2:** GET /api/capacity endpoint returning real-time session availability with appropriate messaging logic

3. **AC3:** GET /api/sessions endpoint returning morning/afternoon time slots with current registration counts

4. **AC4:** Rate limiting implemented on capacity endpoints to prevent abuse during high-traffic periods

5. **AC5:** Caching strategy implemented for package data with 5-minute TTL to reduce database load

6. **AC6:** Capacity logic implemented hiding exact Free availability while showing "เต็มแล้ว" status appropriately

7. **AC7:** Database seeded with initial package, session, and capacity data for development and testing

8. **AC8:** Vercel Edge Config caching layer implemented for static data with Redis caching for session capacity

## Tasks / Subtasks

- [ ] Task 1: Database Seeding Implementation (AC: 7)
  - [ ] Create comprehensive seed script for Package model with Free (฿0) and Advanced (฿690) packages
  - [ ] Add SessionCapacity seed data with morning (09:00-12:00) and afternoon (13:00-16:00) sessions
  - [ ] Seed CapacityStatus model with real-time tracking data and Free/Advanced breakdown
  - [ ] Create UserPackage test data for realistic capacity calculations
  - [ ] Add audit logging seed data for monitoring and debugging
  - [ ] Verify all foreign key relationships and constraints in seeded data

- [ ] Task 2: Hybrid Caching Infrastructure Setup (AC: 5, 8)
  - [ ] Configure Vercel Edge Config for static package data with global edge distribution
  - [ ] Enhance existing Redis (Upstash) utilities in /lib/redis.ts for session capacity
  - [ ] Implement cache key strategies using existing patterns from lib/redis.ts
  - [ ] Create cache invalidation logic for real-time capacity updates using existing Redis patterns
  - [ ] Add Sentry error monitoring integration for cache operations
  - [ ] Add cache fallback mechanisms: Edge Config → Redis → Database

- [ ] Task 3: Package Management API Implementation (AC: 1)
  - [ ] Create GET /api/packages endpoint with Prisma queries
  - [ ] Implement package data serialization with pricing and feature information
  - [ ] Add current availability calculation logic for Free/Advanced packages
  - [ ] Integrate Vercel Edge Config for static package data with Redis fallback for dynamic availability
  - [ ] Add request validation using Zod schemas
  - [ ] Implement error handling and logging for package queries

- [ ] Task 4: Capacity Management API Implementation (AC: 2, 6)
  - [ ] Create GET /api/capacity endpoint with real-time session availability
  - [ ] Implement capacity messaging logic hiding exact Free availability
  - [ ] Add "เต็มแล้ว" status logic when Free tier reaches capacity limits
  - [ ] Integrate Redis caching with 1-minute TTL for capacity data (existing implementation)
  - [ ] Add capacity calculation algorithms for 300 participants per session
  - [ ] Implement capacity threshold warnings for near-full sessions

- [ ] Task 5: Session Management API Implementation (AC: 3)
  - [ ] Create GET /api/sessions endpoint returning time slot information
  - [ ] Implement session registration count calculations with current enrollments
  - [ ] Add session availability status based on current capacity
  - [ ] Integrate Vercel Edge Config for static session data with Redis for current counts
  - [ ] Add session datetime formatting for Thai timezone (UTC+7)
  - [ ] Implement session conflict detection and validation logic

- [ ] Task 6: Rate Limiting Integration (AC: 4)
  - [ ] Apply existing rate limiting middleware from lib/rate-limit.ts to capacity endpoints
  - [ ] Configure capacity-specific rate limits using existing rateLimitConfigs patterns
  - [ ] Utilize existing Upstash Redis rate limiting infrastructure
  - [ ] Add rate limit headers using existing createRateLimitResponse function
  - [ ] Integrate with existing Sentry monitoring and security event logging
  - [ ] Test rate limiting under 20 concurrent users load scenarios

- [ ] Task 7: API Response Optimization and Standards (AC: All)
  - [ ] Implement consistent API response format with success/error handling
  - [ ] Integrate with existing Sentry monitoring for API response time tracking
  - [ ] Optimize database queries using existing Prisma optimized query patterns
  - [ ] Implement request/response compression for large datasets
  - [ ] Add API versioning headers and deprecation notices
  - [ ] Enhance existing error response mapping with Sentry integration

- [ ] Task 8: Integration Testing and Validation (AC: All)
  - [ ] Create unit tests for all API endpoints with mock data scenarios
  - [ ] Implement integration tests for hybrid caching (Edge Config + Redis) functionality
  - [ ] Add load testing for 20 concurrent users and 300 participants capacity
  - [ ] Test rate limiting behavior under various load conditions
  - [ ] Validate capacity calculation accuracy with edge cases
  - [ ] Test cache invalidation and warming strategies

## Dev Notes

### Previous Story Insights

Story 1.3 completed comprehensive database schema with Package, SessionCapacity, UserPackage, and CapacityStatus models. All foreign key relationships are established and database indexes are optimized for high-frequency capacity queries. The database foundation is solid and ready for API implementation.

[Source: docs/stories/1.3.database-schema-creation.md]

### Technology Stack Requirements

[Source: docs/architecture/section-3-tech-stack.md]

- **Backend**: Next.js 14+ API Routes with tRPC for type safety
- **Database**: PostgreSQL 15+ with Prisma ORM on Vercel Postgres  
- **Caching**: Vercel Edge Config for session capacity and configuration (primary), Redis (Upstash) existing implementation (fallback)
- **Rate Limiting**: Existing Upstash Redis rate limiting implementation from lib/rate-limit.ts
- **Monitoring**: Vercel Analytics for performance, Sentry for error tracking and monitoring

### Data Models

[Source: docs/architecture/section-4-data-models.md]

Key models for API implementation:

```typescript
interface Package {
  id: string;
  type: "FREE" | "ADVANCED";
  price: number; // 0 for Free, 69000 satang (690 THB) for Advanced
  features: string[]; // Feature comparison list
  is_active: boolean;
  max_users_per_session?: number; // 150 for Free tier
}

interface SessionCapacity {
  id: string;
  session_time: "09:00-12:00" | "13:00-16:00";
  current_count: number;
  max_capacity: number; // 300 exam participants per session
  exam_date: Date; // 27 กันยายน 2568
  created_at: Date;
  updated_at: Date;
}

interface CapacityStatus {
  id: string;
  session_id: string;
  free_count: number; // Current Free package registrations
  advanced_count: number; // Current Advanced package registrations
  availability_status: "AVAILABLE" | "NEARLY_FULL" | "FULL" | "ADVANCED_ONLY";
  last_updated: Date;
}
```

### API Specifications

[Source: docs/architecture/section-4-data-models.md#api-endpoints]

API endpoints to implement:

1. **GET /api/packages**
   - Returns: Package types with pricing, features, availability
   - Cache: Vercel Edge Config (static data) + Redis fallback
   - Rate limit: 100 requests/minute per user (existing lib/rate-limit.ts)

2. **GET /api/capacity** 
   - Returns: Real-time session availability with messaging
   - Cache: Vercel Edge Config (1-minute TTL) with Redis fallback 
   - Rate limit: 60 requests/minute per user (existing lib/rate-limit.ts)

3. **GET /api/sessions**
   - Returns: Time slots with registration counts
   - Cache: Vercel Edge Config (static) + Redis for dynamic counts
   - Rate limit: 100 requests/minute per user (existing lib/rate-limit.ts)

### File Structure

Based on Next.js 14+ App Router structure:

- `apps/web/app/api/packages/route.ts` - Package management endpoint
- `apps/web/app/api/capacity/route.ts` - Capacity tracking endpoint  
- `apps/web/app/api/sessions/route.ts` - Session information endpoint
- `apps/web/lib/edge-config.ts` - Vercel Edge Config utilities
- `apps/web/lib/redis.ts` - Enhanced Redis caching utilities (existing)
- `apps/web/lib/capacity.ts` - Capacity calculation logic
- `apps/web/prisma/seed.ts` - Database seeding script (enhanced)
- `apps/web/__tests__/api/` - API endpoint tests

### Business Logic Constraints

[Source: docs/architecture/section-4-data-models.md#business-logic]

- **Session Capacity**: 300 exam participants per session (morning + afternoon = 600 total)
- **Free Package Limit**: Maximum 150 Free users per session
- **Concurrent System Users**: Support 20 simultaneous users during registration
- **Capacity Messaging**: Hide exact Free availability numbers, show "เต็มแล้ว" when full
- **Cache Strategy**: Vercel Edge Config for static data, Redis for dynamic data (per existing implementation)

### Security Considerations

- **Rate Limiting**: Prevent capacity scraping and abuse during high-traffic registration
- **Data Validation**: Validate all input parameters using Zod schemas
- **Error Handling**: Avoid exposing internal database structure in error messages
- **Capacity Logic**: Prevent race conditions in capacity calculations
- **Cache Security**: Implement proper cache key namespacing to prevent data leakage

### Performance Requirements

[Source: docs/architecture/section-3-tech-stack.md#performance]

- **Response Time**: < 200ms for capacity queries under 20 concurrent users load
- **Concurrent Users**: Support 20 simultaneous API requests during registration peaks
- **Cache Hit Rate**: Target 80%+ cache hit rate for frequently accessed data
- **Database Optimization**: Use existing Prisma optimized queries and connection pooling
- **Monitoring**: Integrate with existing Sentry error tracking and Vercel Analytics

### Integration Points

- **Frontend Components**: Landing page pricing section and capacity display components from Story 1.2
- **Database**: Prisma models and relationships from Story 1.3
- **Authentication**: NextAuth.js integration for user-based rate limiting
- **Existing Infrastructure**: lib/rate-limit.ts, lib/redis.ts, lib/monitoring.ts
- **Monitoring**: Existing Sentry error tracking integration and Vercel Analytics

## Testing

### Unit Testing

[Source: docs/architecture/section-3-tech-stack.md#quality-assurance]

- **Framework**: Jest 29+ for API endpoint testing
- **Test Location**: `apps/web/__tests__/api/` directory
- **Coverage Requirements**: All API endpoints and utility functions tested
- **Key Test Scenarios**:
  - Package data retrieval with correct pricing and features
  - Capacity calculation logic with various scenarios  
  - Session availability with time slot validation
  - Hybrid caching behavior (Edge Config + Redis) and cache invalidation
  - Rate limiting enforcement using existing lib/rate-limit.ts
  - Database query optimization and performance with Sentry monitoring integration

### Integration Testing

- **Database Integration**: Test API endpoints with real database connections using existing Prisma setup
- **Hybrid Caching Integration**: Validate Edge Config + Redis caching behavior with live instances
- **Performance Testing**: Load test with 20 concurrent users as per architecture requirements
- **Capacity Logic**: Test edge cases like simultaneous registrations using existing business logic

### API Testing

- **Endpoint Testing**: Validate all HTTP methods and response formats
- **Error Handling**: Test various error scenarios and status codes
- **Cache Testing**: Verify hybrid cache warming, invalidation, and TTL behavior (Edge Config + Redis)
- **Rate Limiting**: Test existing rate limit enforcement from lib/rate-limit.ts and recovery

### Test Commands

```bash
npm run test:api          # API endpoint tests
npm run test:integration  # Database and hybrid caching integration tests
npm run test:load         # Load testing for capacity scenarios
npm run seed:dev          # Run development database seeding
npm run cache:test        # Hybrid caching (Edge Config + Redis) functionality tests
```

## Change Log

| Date       | Version | Description                                   | Author |
| ---------- | ------- | --------------------------------------------- | ------ |
| 2025-09-11 | 1.0     | Initial story creation with comprehensive API implementation including seeding and caching | SM Bob |